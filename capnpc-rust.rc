#[link(name = "capnpc-rust", vers = "0.0", author = "dwrensha")];

#[crate_type = "bin"];

extern mod capnprust;

use capnprust::*;

pub mod schema_capnp;

fn typeToString (t : &schema_capnp::Type::Reader) -> ~str {
    use schema_capnp::Type::Body;
    match t.getBody() {
        Body::voidType => { return ~"Void" }
        Body::boolType => { return ~"Bool" }
        Body::int8Type => { return ~"Int8" }
        Body::int16Type => { return ~"Int16" }
        Body::int32Type => { return ~"Int32" }
        Body::int64Type => { return ~"Int64" }
        Body::uint8Type => { return ~"UInt8" }
        Body::uint16Type => { return ~"UInt16" }
        Body::uint32Type => { return ~"UInt32" }
        Body::uint64Type => { return ~"UInt64" }
        Body::float32Type => { return ~"Float32" }
        Body::float64Type => { return ~"Float64" }
        Body::textType => { return ~"Text" }
        Body::dataType => { return ~"Data" }
        Body::listType(t1) => {
            let s1 = typeToString(&t1);
            return fmt!("List(%s)", s1)
        }
        Body::enumType(_) => { return ~"Enum" }
        Body::structType(_) => { return ~"Struct" }
        Body::interfaceType(_) => { return ~"Interface" }
        Body::objectType => { return ~"Object" }
    }
}

fn camelCaseToAllCaps(s : &str) -> ~str {
    let bytes = s.as_bytes();
    let mut result_bytes : ~[u8] = ~[];
    for bytes.iter().advance |&b| {

        // strings will be null-terminated
        if (b != 0) {
            let c = b as char;
            assert!(std::char::is_alphabetic(c), fmt!("not alphabetic '%c'", c));
            if (std::char::is_uppercase(c)) {
                result_bytes.push('_' as u8);
            }

            let b1 = unsafe {
                std::libc::toupper(b as std::libc::c_char) as u8
            };

            result_bytes.push(b1);
        }
    }
    return std::str::from_bytes(result_bytes);
}

#[test]
fn testCamelCaseToAllCaps() {
    assert_eq!(camelCaseToAllCaps("fooBar"), ~"FOO_BAR");
    assert_eq!(camelCaseToAllCaps("fooBarBaz"), ~"FOO_BAR_BAZ");
    assert_eq!(camelCaseToAllCaps("helloWorld"), ~"HELLO_WORLD");
}

enum FormattedText {
    Indent(~FormattedText),
    Branch(~[FormattedText]),
    Line(~str)
}

// This is all quite inefficient.
fn toLines(ft : &FormattedText) -> ~[~str] {

    match *ft {
        Indent (ref ft) => {
            let strs = toLines(*ft);
            let mut result : ~[~str]= ~[];
            for strs.iter().advance |s| {
                let mut s1 : ~str = ~"  ";
                s1.push_str(*s);
                result.push(s1)
            }
            return result;
        }
        Branch (ref fts) => {
            return do fts.flat_map |ft| {toLines(ft)};
        }
        Line(ref s) => return ~[s.to_owned()]
    }
}

fn stringify(ft : & FormattedText) -> ~str {
    toLines(ft).connect("\n")
}

fn appendName (names : &[~str], name : ~str) -> ~[~str] {
    let mut result : ~[~str] = ~[];
    for names.iter().advance |n| {
        result.push(n.to_owned());
    }
    result.push(name);
    return result;
}

//type NodeMap = std::hashmap::HashMap<u64, schema_capnp::Node::Reader>;

fn populateScopeMap(nodeMap : &std::hashmap::HashMap<u64, schema_capnp::Node::Reader>,
                    scopeMap : &mut std::hashmap::HashMap<u64, ~[~str]>,
                    nodeId : u64) {
    let nodeReader = nodeMap.get(&nodeId);

    let nestedNodes = nodeReader.getNestedNodes();
    for std::uint::range(0, nestedNodes.size()) |ii| {
        let nestedNode = nestedNodes.get(ii);
        let id = nestedNode.getId();
        let name = nestedNode.getName().to_owned();

        let scopeNames = {
            if (scopeMap.contains_key(&nodeId)) {
                let names = scopeMap.get(&nodeId);
                appendName(*names, name)
            } else {
                ~[name]
            }
        };
        scopeMap.insert(id, scopeNames);
        populateScopeMap(nodeMap, scopeMap, id);
    }
}

fn generateNode(nodeMap : &std::hashmap::HashMap<u64, schema_capnp::Node::Reader>,
                scopeMap : &std::hashmap::HashMap<u64, ~[~str]>,
                nodeId : u64) -> FormattedText {
    use schema_capnp::*;

    let nodeReader = nodeMap.get(&nodeId);

    let displayName = nodeReader.getDisplayName();
    std::io::println(fmt!("node with name: %s", displayName));

    std::io::println(fmt!( "  scopeId: %x", nodeReader.getScopeId() as uint));

    let mut output: ~[FormattedText] = ~[];

    let mut nested_output: ~[FormattedText] = ~[];

    let nestedNodes = nodeReader.getNestedNodes();
    for std::uint::range(0, nestedNodes.size()) |ii| {
        let nestedNode = nestedNodes.get(ii);
        let id = nestedNode.getId();
        let name = nestedNode.getName().to_owned();

        std::io::println(fmt!("  nested node with name: %s and id: %x",
                              name, id as uint));
        let text = generateNode(nodeMap, scopeMap, id);
        nested_output.push(text);
    }

    match nodeReader.getBody() {

        Node::Body::FILE_NODE(fileNode) => {
            let imports = fileNode.getImports();
            for std::uint::range(0, imports.size()) |ii| {
                println!("  import %s", imports.get(ii).getName());
            }
            output.push(Branch(nested_output));
        }

        Node::Body::STRUCT_NODE(structNode) => {
            std::io::println(fmt!("  struct node. data size: %?, pointer size: %?",
                                  structNode.getDataSectionWordSize(),
                                  structNode.getPointerSectionSize()));
            let names = scopeMap.get(&nodeId);
            output.push(Line(fmt!("pub mod %s {", *names.last())));

            let members = structNode.getMembers();
            for std::uint::range(0, members.size()) |ii| {
                let member = members.get(ii);
                let name = member.getName();
                match member.getBody() {
                    StructNode::Member::Body::FIELD_MEMBER(field) => {
                        let offset = field.getOffset() as uint;
                        std::io::println(
                            fmt!("    field %s : %s  at offset %u",
                                 name, typeToString(&field.getType()), offset));
                    }
                    StructNode::Member::Body::UNION_MEMBER(union) => {
                        let doffset = union.getDiscriminantOffset() as uint;
                        std::io::println(
                            fmt!("    union field %s with discriminant offset %u",
                                 name, doffset));
                        let members = union.getMembers();
                        for std::uint::range(0, members.size()) |ii| {
                            println!("      %s", members.get(ii).getName());
                        }
                    }
                }
            }

            output.push(Indent(~Branch(nested_output)));
            output.push(Line(~"}"));
        }

        Node::Body::ENUM_NODE(enumNode) => {
            let names = scopeMap.get(&nodeId);
            output.push(Line(fmt!("pub mod %s {", *names.last())));

            let mut members = ~[];
            let enumerants = enumNode.getEnumerants();
            for std::uint::range(0, enumerants.size()) |ii| {
                println!("    %s = %u,", enumerants.get(ii).getName(), ii);
                let enumerant = enumerants.get(ii);
                members.push(
                    Line(fmt!("%s = %u,", camelCaseToAllCaps(enumerant.getName()), ii)));
            }

            output.push(Indent(~Branch(~[Line(~"pub enum Reader {"),
                                         Indent(~Branch(members)),
                                         Line(~"}")])));
            output.push(Line(~"}"));
        }

        Node::Body::INTERFACE_NODE(_) => { }

        Node::Body::CONST_NODE(_) => { }

        Node::Body::ANNOTATION_NODE( annotationNode ) => {
            std::io::println("  annotation node:");
            if (annotationNode.getTargetsFile()) {
                std::io::println("  targets file");
            }
            if (annotationNode.getTargetsConst()) {
                std::io::println("  targets const");
            }
            // ...
            if (annotationNode.getTargetsAnnotation()) {
                std::io::println("  targets annotation");
            }
        }
    }

    Branch(output)
}


fn main() {
    use capnprust::serialize::*;

    let inp = std::io::stdin();

    do InputStreamMessageReader::new(inp, message::DEFAULT_READER_OPTIONS) | messageReader | {
        let structReader = messageReader.getRoot();

        let codeGeneratorRequest =
            schema_capnp::CodeGeneratorRequest::Reader::new(structReader);

        let mut nodeMap = std::hashmap::HashMap::new::<u64, schema_capnp::Node::Reader>();
        let mut scopeMap = std::hashmap::HashMap::new::<u64, ~[~str]>();

        let nodeListReader = codeGeneratorRequest.getNodes();

        for std::uint::range(0, nodeListReader.size()) |ii| {

            let nodeReader = nodeListReader.get(ii);
            let id = nodeReader.getId();

            nodeMap.insert(id, nodeReader);
        }

        let requestedFilesReader = codeGeneratorRequest.getRequestedFiles();

        for std::uint::range(0, requestedFilesReader.size()) |ii| {

            let requestedFileId : u64 = requestedFilesReader.get(ii);
            std::io::println(fmt!("requested file: %x",
                                  requestedFileId as uint));

            populateScopeMap(&nodeMap, &mut scopeMap, requestedFileId);
            println!("%?", scopeMap);
            let text = stringify(&generateNode(&nodeMap, &scopeMap, requestedFileId));

            let path = &std::path::Path("test.out");
            match std::io::mk_file_writer(path, [std::io::Create, std::io::Truncate]) {
                Ok(writer) => { writer.write( text.as_bytes() )}
                Err(msg) => {println!("ERROR: %s", msg)}
            }

        }

        0;
    }
}