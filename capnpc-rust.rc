#[link(name = "capnpc-rust", vers = "0.0", author = "dwrensha")];

#[crate_type = "bin"];

extern mod capnprust;

use capnprust::*;

pub mod schema_capnp;

fn typeToString (t : &schema_capnp::Type::Reader) -> ~str {
    use schema_capnp::Type::Body;
    match t.getBody() {
        Body::voidType => { return ~"Void" }
        Body::boolType => { return ~"Bool" }
        Body::int8Type => { return ~"Int8" }
        Body::int16Type => { return ~"Int16" }
        Body::int32Type => { return ~"Int32" }
        Body::int64Type => { return ~"Int64" }
        Body::uint8Type => { return ~"UInt8" }
        Body::uint16Type => { return ~"UInt16" }
        Body::uint32Type => { return ~"UInt32" }
        Body::uint64Type => { return ~"UInt64" }
        Body::float32Type => { return ~"Float32" }
        Body::float64Type => { return ~"Float64" }
        Body::textType => { return ~"Text" }
        Body::dataType => { return ~"Data" }
        Body::listType(t1) => {
            let s1 = typeToString(&t1);
            return fmt!("List(%s)", s1)
        }
        Body::enumType(_) => { return ~"Enum" }
        Body::structType(_) => { return ~"Struct" }
        Body::interfaceType(_) => { return ~"Interface" }
        Body::objectType => { return ~"Object" }
    }
}

fn camelCaseToAllCaps(s : &str) -> ~str {
    let bytes = s.as_bytes();
    let mut result_bytes : ~[u8] = ~[];
    for bytes.iter().advance |&b| {

        // strings will be null-terminated
        if (b != 0) {
            let c = b as char;
            assert!(std::char::is_alphanumeric(c), fmt!("not alphanumeric '%c'", c));
            if (std::char::is_uppercase(c)) {
                result_bytes.push('_' as u8);
            }

            let b1 = unsafe {
                std::libc::toupper(b as std::libc::c_char) as u8
            };

            result_bytes.push(b1);
        }
    }
    return std::str::from_bytes(result_bytes);
}

fn capitalizeFirstLetter(s : &str) -> ~str {
    let bytes = s.as_bytes();
    let mut result_bytes : ~[u8] = ~[];
    for bytes.iter().advance |&b| {
        result_bytes.push(b);
    }

    result_bytes[0] = unsafe {
        std::libc::toupper(result_bytes[0] as std::libc::c_char) as u8
    };

    return std::str::from_bytes(result_bytes);
}

#[test]
fn testCamelCaseToAllCaps() {
    assert_eq!(camelCaseToAllCaps("fooBar"), ~"FOO_BAR");
    assert_eq!(camelCaseToAllCaps("fooBarBaz"), ~"FOO_BAR_BAZ");
    assert_eq!(camelCaseToAllCaps("helloWorld"), ~"HELLO_WORLD");
}

enum FormattedText {
    Indent(~FormattedText),
    Branch(~[FormattedText]),
    Line(~str),
    BlankLine
}

fn toLines(ft : &FormattedText, indent : uint) -> ~[~str] {
    match *ft {
        Indent (ref ft) => {
            return toLines(*ft, indent + 1);
        }
        Branch (ref fts) => {
            return do fts.flat_map |ft| {toLines(ft, indent)};
        }
        Line(ref s) => {
            let mut s1 : ~str = std::str::from_chars(
                std::vec::from_elem(indent * 2, ' '));
            s1.push_str(*s);
            return ~[s1];
        }
        BlankLine => return ~[~""]
    }
}

fn stringify(ft : & FormattedText) -> ~str {
    let mut result = toLines(ft, 0).connect("\n");
    result.push_str("\n");
    return result;
}

fn appendName (names : &[~str], name : ~str) -> ~[~str] {
    let mut result : ~[~str] = ~[];
    for names.iter().advance |n| {
        result.push(n.to_owned());
    }
    result.push(name);
    return result;
}

//type NodeMap = std::hashmap::HashMap<u64, schema_capnp::Node::Reader>;

fn populateScopeMap(nodeMap : &std::hashmap::HashMap<u64, schema_capnp::Node::Reader>,
                    scopeMap : &mut std::hashmap::HashMap<u64, ~[~str]>,
                    nodeId : u64) {
    let nodeReader = nodeMap.get(&nodeId);

    let nestedNodes = nodeReader.getNestedNodes();
    for std::uint::range(0, nestedNodes.size()) |ii| {
        let nestedNode = nestedNodes.get(ii);
        let id = nestedNode.getId();
        let name = nestedNode.getName().to_owned();

        let scopeNames = {
            if (scopeMap.contains_key(&nodeId)) {
                let names = scopeMap.get(&nodeId);
                appendName(*names, name)
            } else {
                ~[name]
            }
        };
        scopeMap.insert(id, scopeNames);
        populateScopeMap(nodeMap, scopeMap, id);
    }
}


// Return (union_mod, union_getter)
fn generateUnion(nodeMap : &std::hashmap::HashMap<u64, schema_capnp::Node::Reader>,
                 scopeMap : &std::hashmap::HashMap<u64, ~[~str]>,
                 name : &str,
                 union : schema_capnp::StructNode::Union::Reader)
    -> (FormattedText, FormattedText) {

    let mut result = ~[];

    let mut getter_interior = ~[];

    let capitalizedName = capitalizeFirstLetter(name);

    result.push(Line(fmt!("pub mod %s {", capitalizedName)));
    let mut interior = ~[];
    let mut reader_interior = ~[];
    let mut builder_interior = ~[];

    builder_interior.push(
        Line(~"pub fn new(builder : StructBuilder) -> Builder { Builder { _builder : builder }}"));

    let doffset = union.getDiscriminantOffset() as uint;

    let members = union.getMembers();
    for std::uint::range(0, members.size()) |ii| {
        let member = members.get(ii);
        let memberName = member.getName();
        let enumerantName = camelCaseToAllCaps(memberName);
        reader_interior.push(Line(fmt!("%s,",enumerantName)));

        builder_interior.push(
            Branch(~[
                Line(~"#[inline]"),
                Line(fmt!("pub fn set%s(&self) {", memberName)),
                Indent(
                    ~Line(
                        fmt!("self._builder.setDataField::<u16>(%u, %u);", doffset, ii))),
                Line(~"}")
            ])
        );

        getter_interior.push(Branch(~[
            Line(fmt!("%u => {", ii)),
            Indent(~Line(fmt!("return %s::%s(%s);", capitalizedName, enumerantName, "TODO"))),
            Line(~"}")
        ]));
    }

    getter_interior.push(Line(~"_ => fail!(\"impossible\")"));

    interior.push(
        Branch(~[Line(~"pub enum Reader<'self> {"),
                 Indent(~Branch(reader_interior)),
                 Line(~"}")]));
    interior.push(
        Line(~"pub struct Builder { _builder : StructBuiler }"));
    interior.push(
        Branch(~[Line(~"impl Builder {"),
                 Indent(~Branch(builder_interior)),
                 Line(~"}")]));


    result.push(Indent(~Branch(interior)));
    result.push(Line(~"}"));


    let getter_result =
        Branch(~[Line(~"#[inline]"),
                 Line(fmt!("pub fn get%s(&self) -> %s::Reader<'self> {",
                           capitalizedName, capitalizedName)),
                 Indent(~Branch(~[
                     Line(fmt!("match self._reader.getDataField::<u16>(%u) {", doffset)),
                     Indent(~Branch(getter_interior)),
                     Line(~"}")
                 ])),
                 Line(~"}")]);

    return (Branch(result), getter_result);
}

fn generateNode(nodeMap : &std::hashmap::HashMap<u64, schema_capnp::Node::Reader>,
                scopeMap : &std::hashmap::HashMap<u64, ~[~str]>,
                nodeId : u64) -> FormattedText {
    use schema_capnp::*;

    let nodeReader = nodeMap.get(&nodeId);

    let _displayName = nodeReader.getDisplayName();

    let mut output: ~[FormattedText] = ~[];

    let mut nested_output: ~[FormattedText] = ~[];

    let nestedNodes = nodeReader.getNestedNodes();
    for std::uint::range(0, nestedNodes.size()) |ii| {
        let nestedNode = nestedNodes.get(ii);
        let id = nestedNode.getId();
        let name = nestedNode.getName().to_owned();
        let text = generateNode(nodeMap, scopeMap, id);
        nested_output.push(text);
    }

    match nodeReader.getBody() {

        Node::Body::FILE_NODE(fileNode) => {
            let imports = fileNode.getImports();
            for std::uint::range(0, imports.size()) |ii| {
                printfln!("  import %s", imports.get(ii).getName());
            }
            output.push(Branch(nested_output));
        }

        Node::Body::STRUCT_NODE(structNode) => {

            let names = scopeMap.get(&nodeId);
            output.push(BlankLine);
            output.push(Line(fmt!("pub mod %s {", *names.last())));

            let mut preamble = ~[];
            let mut builder_members = ~[];
            let mut reader_members = ~[];
            let mut union_mods = ~[];

            let dataSize = structNode.getDataSectionWordSize();
            let pointerSize = structNode.getPointerSectionSize();
            let preferredListEncoding = structNode.getPreferredListEncoding();

            preamble.push(Line(~"pub static STRUCT_SIZE : StructSize = "));
            preamble.push(
                Indent(
                    ~Line(
                        fmt!("StructSize { data : %u, pointers : %u, preferredListEncoding : %s};",
                         dataSize as uint, pointerSize as uint,
                         preferredListEncoding.to_str()))));

            let members = structNode.getMembers();
            for std::uint::range(0, members.size()) |ii| {
                let member = members.get(ii);
                let name = member.getName();
                let capName = capitalizeFirstLetter(name);
                match member.getBody() {
                    StructNode::Member::Body::FIELD_MEMBER(field) => {
                        let offset = field.getOffset() as uint;
                        let typ = field.getType();

                        reader_members.push(
                            Branch(~[
                                Line(~"#[inline]"),
                                Line(fmt!("pub fn get%s(&self) {", capName)),
                                Indent(~Line(~"self._reader.getDataField")),
                                Line(~"}")
                            ])
                        );
                    }
                    StructNode::Member::Body::UNION_MEMBER(union) => {
                        let (union_mod, union_getter) =
                            generateUnion(nodeMap, scopeMap, name, union);
                        union_mods.push(union_mod);
                        reader_members.push(union_getter);
                    }
                }
            }

            let accessors =
                ~[Branch(preamble),
                  Line(~"pub struct Reader<'self> { _reader : StructReader<'self> }"),
                  Line(~"impl <'self> Reader<'self> {"),
                  Indent(
                      ~Branch(
                          ~[Line(~"pub fn new<'a>(reader : StructReader<'a>) -> Reader<'a> {"),
                            Indent(~Line(~"Reader { _reader : reader }")),
                            Line(~"}")
                            ])),
                  Indent(~Branch(reader_members)),
                  Line(~"}"),

                  Line(~"pub struct Builder { _builder : StructBuiler }"),
                  Line(~"impl Builder {"),
                  Indent(
                      ~Branch(
                          ~[Line(~"pub fn new(builder : StructBuilder) -> Builder {"),
                            Indent(~Line(~"Builder { _builder : builder }")),
                            Line(~"}")
                            ])),
                  Indent(~Branch(builder_members)),
                  Line(~"}")];

            output.push(Indent(~Branch(~[Branch(accessors),
                                         Branch(union_mods),
                                         Branch(nested_output)])));
            output.push(Line(~"}"));
        }

        Node::Body::ENUM_NODE(enumNode) => {
            let names = scopeMap.get(&nodeId);
            output.push(Line(fmt!("pub mod %s {", *names.last())));

            let mut members = ~[];
            let enumerants = enumNode.getEnumerants();
            for std::uint::range(0, enumerants.size()) |ii| {
                let enumerant = enumerants.get(ii);
                members.push(
                    Line(fmt!("%s = %u,", camelCaseToAllCaps(enumerant.getName()), ii)));
            }

            output.push(Indent(~Branch(~[Line(~"pub enum Reader {"),
                                         Indent(~Branch(members)),
                                         Line(~"}")])));
            output.push(Line(~"}"));
        }

        Node::Body::INTERFACE_NODE(_) => { }

        Node::Body::CONST_NODE(_) => { }

        Node::Body::ANNOTATION_NODE( annotationNode ) => {
            std::io::println("  annotation node:");
            if (annotationNode.getTargetsFile()) {
                std::io::println("  targets file");
            }
            if (annotationNode.getTargetsConst()) {
                std::io::println("  targets const");
            }
            // ...
            if (annotationNode.getTargetsAnnotation()) {
                std::io::println("  targets annotation");
            }
        }
    }

    Branch(output)
}


fn main() {
    use capnprust::serialize::*;

    let inp = std::io::stdin();

    do InputStreamMessageReader::new(inp, message::DEFAULT_READER_OPTIONS) | messageReader | {
        let structReader = messageReader.getRoot();

        let codeGeneratorRequest =
            schema_capnp::CodeGeneratorRequest::Reader::new(structReader);

        let mut nodeMap = std::hashmap::HashMap::new::<u64, schema_capnp::Node::Reader>();
        let mut scopeMap = std::hashmap::HashMap::new::<u64, ~[~str]>();

        let nodeListReader = codeGeneratorRequest.getNodes();

        for std::uint::range(0, nodeListReader.size()) |ii| {

            let nodeReader = nodeListReader.get(ii);
            let id = nodeReader.getId();

            nodeMap.insert(id, nodeReader);
        }

        let requestedFilesReader = codeGeneratorRequest.getRequestedFiles();

        for std::uint::range(0, requestedFilesReader.size()) |ii| {

            let requestedFileId : u64 = requestedFilesReader.get(ii);
            std::io::println(fmt!("requested file: %x",
                                  requestedFileId as uint));

            populateScopeMap(&nodeMap, &mut scopeMap, requestedFileId);
            let text = stringify(&generateNode(&nodeMap, &scopeMap, requestedFileId));

            let path = &std::path::Path("test.out");
            match std::io::mk_file_writer(path, [std::io::Create, std::io::Truncate]) {
                Ok(writer) => { writer.write( text.as_bytes() )}
                Err(msg) => {printfln!("ERROR: %s", msg)}
            }

        }

        0;
    }
}