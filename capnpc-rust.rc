#[link(name = "capnpc-rust", vers = "0.0", author = "dwrensha")];

#[crate_type = "bin"];

extern mod capnprust;

use capnprust::*;

pub mod schema_capnp;

fn typeToString (t : &schema_capnp::Type::Reader) -> ~str {
    use schema_capnp::Type::Body;
    match t.getBody() {
        Body::voidType => { return ~"Void" }
        Body::boolType => { return ~"Bool" }
        Body::int8Type => { return ~"Int8" }
        Body::int16Type => { return ~"Int16" }
        Body::int32Type => { return ~"Int32" }
        Body::int64Type => { return ~"Int64" }
        Body::uint8Type => { return ~"UInt8" }
        Body::uint16Type => { return ~"UInt16" }
        Body::uint32Type => { return ~"UInt32" }
        Body::uint64Type => { return ~"UInt64" }
        Body::float32Type => { return ~"Float32" }
        Body::float64Type => { return ~"Float64" }
        Body::textType => { return ~"Text" }
        Body::dataType => { return ~"Data" }
        Body::listType(t1) => {
            let s1 = typeToString(&t1);
            return fmt!("List(%s)", s1)
        }
        Body::enumType(_) => { return ~"Enum" }
        Body::structType(_) => { return ~"Struct" }
        Body::interfaceType(_) => { return ~"Interface" }
        Body::objectType => { return ~"Object" }
    }
}

fn camelCaseToAllCaps(s : &str) -> ~str {
    let bytes = s.as_bytes();
    let mut result_bytes : ~[u8] = ~[];
    for bytes.iter().advance |&b| {
        let c = b as char;
        assert!(std::char::is_alphabetic(c));
        if (std::char::is_uppercase(c)) {
            result_bytes.push('_' as u8);
        }

        let b1 = unsafe {
            std::libc::toupper(b as std::libc::c_char) as u8
        };

        result_bytes.push(b1);
    }
    return std::str::from_bytes(result_bytes);
}

#[test]
fn testCamelCaseToAllCaps() {
    assert_eq!(camelCaseToAllCaps("fooBar"), ~"FOO_BAR");
    assert_eq!(camelCaseToAllCaps("fooBarBaz"), ~"FOO_BAR_BAZ");
    assert_eq!(camelCaseToAllCaps("helloWorld"), ~"HELLO_WORLD");
}

enum FormattedText {
    Indent(~FormattedText),
    Branch(~[~FormattedText]),
    Line(~str)
}

fn stringify(ft : ~FormattedText) -> ~str {
    match *ft {
        Indent (_) => { fail!() }
        Branch (_) => { fail!() }
        Line(s) => return s
    }
}

fn appendName (names : &[~str], name : ~str) -> ~[~str] {
    let result : ~[~str] = ~[];
    for names.iter().advance |n| {
//        result.push(n.to_owned());
    }
    fail!()
}

//type NodeMap = std::hashmap::HashMap<u64, schema_capnp::Node::Reader>;

fn generateNode(nodeMap : &std::hashmap::HashMap<u64, schema_capnp::Node::Reader>,
                names : &[~str], nodeId : u64) -> ~FormattedText {
    use schema_capnp::*;

    let nodeReader = nodeMap.get(&nodeId);

    let displayName = nodeReader.getDisplayName();
    std::io::println(fmt!("node with name: %s", displayName));

    std::io::println(fmt!( "  scopeId: %x", nodeReader.getScopeId() as uint));

    let mut output: ~[~FormattedText] = ~[];

    let mut nested_output: ~[~FormattedText] = ~[];

    let nestedNodes = nodeReader.getNestedNodes();
    for std::uint::range(0, nestedNodes.size()) |ii| {
        let nestedNode = nestedNodes.get(ii);
        let id = nestedNode.getId();
        let name = nestedNode.getName();
        std::io::println(fmt!("  nested node with name: %s and id: %x",
                              name, id as uint));
        let text = generateNode(nodeMap, names, id);
        nested_output.push(text);
    }

    match nodeReader.getBody() {

        Node::Body::FILE_NODE(fileNode) => {
            let imports = fileNode.getImports();
            for std::uint::range(0, imports.size()) |ii| {
                println!("  import %s", imports.get(ii).getName());
            }
        }

        Node::Body::STRUCT_NODE(structNode) => {
            std::io::println(fmt!("  struct node. data size: %?, pointer size: %?",
                                  structNode.getDataSectionWordSize(),
                                  structNode.getPointerSectionSize()));

            let members = structNode.getMembers();
            for std::uint::range(0, members.size()) |ii| {
                let member = members.get(ii);
                let name = member.getName();
                match member.getBody() {
                    StructNode::Member::Body::FIELD_MEMBER(field) => {
                        let offset = field.getOffset() as uint;
                        std::io::println(
                            fmt!("    field %s : %s  at offset %u",
                                 name, typeToString(&field.getType()), offset));
                    }
                    StructNode::Member::Body::UNION_MEMBER(union) => {
                        let doffset = union.getDiscriminantOffset() as uint;
                        std::io::println(
                            fmt!("    union field %s with discriminant offset %u",
                                 name, doffset));
                        let members = union.getMembers();
                        for std::uint::range(0, members.size()) |ii| {
                            println!("      %s", members.get(ii).getName());
                        }
                    }
                }
            }
        }

        Node::Body::ENUM_NODE(enumNode) => {
            let enumerants = enumNode.getEnumerants();
            for std::uint::range(0, enumerants.size()) |ii| {
                println!("    %s", enumerants.get(ii).getName());
            }
        }

        Node::Body::INTERFACE_NODE(_) => { }

        Node::Body::CONST_NODE(_) => { }

        Node::Body::ANNOTATION_NODE( annotationNode ) => {
            std::io::println("  annotation node:");
            if (annotationNode.getTargetsFile()) {
                std::io::println("  targets file");
            }
            if (annotationNode.getTargetsConst()) {
                std::io::println("  targets const");
            }
            // ...
            if (annotationNode.getTargetsAnnotation()) {
                std::io::println("  targets annotation");
            }
        }
    }



    ~Line(~"testing")
}


fn main() {
    use capnprust::serialize::*;


    let inp = std::io::stdin();

    do InputStreamMessageReader::new(inp, message::DEFAULT_READER_OPTIONS) | messageReader | {
        let structReader = messageReader.getRoot();

        let codeGeneratorRequest =
            schema_capnp::CodeGeneratorRequest::Reader::new(structReader);

        let mut nodeMap = std::hashmap::HashMap::new::<u64, schema_capnp::Node::Reader>();

        let nodeListReader = codeGeneratorRequest.getNodes();

        for std::uint::range(0, nodeListReader.size()) |ii| {
            use schema_capnp::*;

            let nodeReader = nodeListReader.get(ii);
            let id = nodeReader.getId();

            nodeMap.insert(id, nodeReader);
        }

        let requestedFilesReader = codeGeneratorRequest.getRequestedFiles();

        for std::uint::range(0, requestedFilesReader.size()) |ii| {

            let requestedFileId : u64 = requestedFilesReader.get(ii);
            std::io::println(fmt!("requested file: %x",
                                  requestedFileId as uint));

            let names : ~[~str] = ~[];
            let text = stringify(generateNode(&nodeMap, names, requestedFileId));

            let path = &std::path::Path("test.out");
            match std::io::mk_file_writer(path, [std::io::Create, std::io::Truncate]) {
                Ok(writer) => { writer.write( text.as_bytes() )}
                Err(msg) => {println!("ERROR: %s", msg)}
            }

        }

        0;
    }
}